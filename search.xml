<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Objective-C的多线程]]></title>
    <url>%2F2019%2F09%2F02%2FObjective-C%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、NSThread1.使用123456//类方法创建[NSThread detachNewThreadWithBlock: ^&#123; NSLog(@&quot;This a thread.&quot;); &#125;];//实例方法创建NSThread *thread = [[NSThread alloc] initWithBlock: ^&#123; NSLog(@&quot;This is a thread.&quot;); &#125;];[thread start]; 当使用类方法创建时，线程自动开始运运行程序，无需调用start方法。 2.线程间的同步 使用@synchronized关键字 12345678910111213141516171819202122232425self.ticket = 20;//创建线程运行的代码块void (^block)(int) = ^(int pid)&#123; while(YES) &#123; [NSThread sleepForTimeInterval: 1]; @synchronized (self) &#123; //加锁 if (self.ticket &gt; 0) &#123; self.ticket--; &#125; NSLog(@&quot;%d tickets left in %d&quot;, self.ticket, pid); &#125; &#125;&#125;;NSThread *threadOne = [[NSThread alloc] initWithBlock: ^&#123; block(1);&#125;];NSThread *threadTwo = [[NSThread alloc] initWithBlock:^&#123; block(2);&#125;];[threadOne start];[threadTwo start]; 使用NSLock 1234567891011121314151617181920212223242526self.ticket = 20; NSLock __block *lock = [[NSLock alloc] init];void (^block)(int) = ^(int pid)&#123; while(YES) &#123; [NSThread sleepForTimeInterval: 1]; [lock lock]; if (self.ticket &gt; 0) &#123; self.ticket--; &#125; NSLog(@&quot;%d tickets left in %d&quot;, self.ticket, pid); [lock unlock]; &#125;&#125;;NSThread *threadOne = [[NSThread alloc] initWithBlock: ^&#123; block(1);&#125;];NSThread *threadTwo = [[NSThread alloc] initWithBlock:^&#123; block(2);&#125;];[threadOne start];[threadTwo start]; 二、GCD(Grand Central Dispatch) GCD是一种基于C语言的并发编程技术。它是苹果为多核的并行运算提出的解决方案，会自动调度系统资源，所以它的效率很高。 GCD并不直接操作线程，而是操作队列和任务。我们只需要把任务添加到队列里，然后指定任务执行的方式，GCD就会自动调度线程执行任务。 GCD的任务都是以Block形式存在的。 1.GCD队列 串行队列：只能等一个任务执行完毕才可以继续调度下一个任务 1dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL); 并发队列：可以同时调度多个任务 1dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); 2.执行任务方式 同步执行：会等待当前任务完成才会执行下一个任务，不会开启新线程 1234typedef void (^dispatch_block_t)(void);//第一次参数对分发任务的GCD队列，第二个为代码块dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 异步执行：不会等待当前任务完成就会执行下一个任务，可以开启新线程（如果是主队列，则不会开启新线程，因为主队列的任务都会在主线程执行）。 1dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 3.GCD的使用 串行队列同步执行 12345678910111213141516171819dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL); // 创建一个串行队列for(int i = 0; i &lt; 10; i++) &#123; //任务同步执行 dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;%d %@&quot;, i, [NSThread currentThread]); &#125;);&#125;//运行结果2019-07-26 11:04:34.513316+0800 HelloOC[15914:1285147] 0 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513502+0800 HelloOC[15914:1285147] 1 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513519+0800 HelloOC[15914:1285147] 2 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513533+0800 HelloOC[15914:1285147] 3 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513545+0800 HelloOC[15914:1285147] 4 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513556+0800 HelloOC[15914:1285147] 5 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513567+0800 HelloOC[15914:1285147] 6 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513579+0800 HelloOC[15914:1285147] 7 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513590+0800 HelloOC[15914:1285147] 8 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:04:34.513602+0800 HelloOC[15914:1285147] 9 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125; 可以看到同步执行的方式并没有开启新线程，打印结果也是顺序的。 并发队列同步执行 12345678910111213141516171819dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //创建一个并发队列 for(int i = 0; i &lt; 10; i++) &#123; //任务同步执行 dispatch_sync(concurrentQueue, ^&#123; NSLog(@&quot;%d %@&quot;, i, [NSThread currentThread]); &#125;); &#125;//运行结果2019-07-26 11:07:26.030043+0800 HelloOC[15922:1287657] 0 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030228+0800 HelloOC[15922:1287657] 1 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030248+0800 HelloOC[15922:1287657] 2 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030262+0800 HelloOC[15922:1287657] 3 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030274+0800 HelloOC[15922:1287657] 4 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030287+0800 HelloOC[15922:1287657] 5 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030299+0800 HelloOC[15922:1287657] 6 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030311+0800 HelloOC[15922:1287657] 7 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030322+0800 HelloOC[15922:1287657] 8 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125;2019-07-26 11:07:26.030335+0800 HelloOC[15922:1287657] 9 &lt;NSThread: 0x1007035e0&gt;&#123;number = 1, name = main&#125; 可以看到同步执行的情况下，无论是串行队列还是并发队列，结果并没有区别，这是因为在同步执行的情况下并不会开启新的线程，所有任务都只能在一条线程上执行，而同一条线程上的任务只能串行执行，所以即使并发队列拥有同时调度多个任务的能力，但是在一条线程的情况下，也只能等前一个任务执行完毕再调度新的任务去执行。所以，在同步执行任务的情况下，串行队列和并发队列的运行结果是一致的。 串行队列异步执行 12345678910111213141516171819dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL); // 创建一个串行队列 for(int i = 0; i &lt; 10; i++) &#123; //任务异步执行 dispatch_async(serialQueue, ^&#123; NSLog(@&quot;%d %@&quot;, i, [NSThread currentThread]); &#125;); &#125;//运行结果2019-07-26 11:16:56.341894+0800 HelloOC[16002:1296692] 0 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342105+0800 HelloOC[16002:1296692] 1 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342124+0800 HelloOC[16002:1296692] 2 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342138+0800 HelloOC[16002:1296692] 3 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342150+0800 HelloOC[16002:1296692] 4 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342161+0800 HelloOC[16002:1296692] 5 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342173+0800 HelloOC[16002:1296692] 6 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342184+0800 HelloOC[16002:1296692] 7 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342196+0800 HelloOC[16002:1296692] 8 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:16:56.342208+0800 HelloOC[16002:1296692] 9 &lt;NSThread: 0x1006000c0&gt;&#123;number = 2, name = (null)&#125; 这种情况下任务是顺序执行的，但是它是在子线程执行的。因为异步执行可以开启新线程，但是由于是串行队列，所以任务只能一个一个顺序执行。 并发队列异步执行 12345678910111213141516171819dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //创建一个并发队列 for(int i = 0; i &lt; 10; i++) &#123; //任务异步执行 dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;%d %@&quot;, i, [NSThread currentThread]); &#125;); &#125;//运行结果2019-07-26 11:19:33.867064+0800 HelloOC[16012:1298763] 1 &lt;NSThread: 0x100726470&gt;&#123;number = 3, name = (null)&#125;2019-07-26 11:19:33.867214+0800 HelloOC[16012:1298768] 6 &lt;NSThread: 0x10393bd80&gt;&#123;number = 8, name = (null)&#125;2019-07-26 11:19:33.867225+0800 HelloOC[16012:1298761] 0 &lt;NSThread: 0x10393b4e0&gt;&#123;number = 2, name = (null)&#125;2019-07-26 11:19:33.867242+0800 HelloOC[16012:1298767] 5 &lt;NSThread: 0x100613da0&gt;&#123;number = 7, name = (null)&#125;2019-07-26 11:19:33.867338+0800 HelloOC[16012:1298764] 2 &lt;NSThread: 0x103b19780&gt;&#123;number = 4, name = (null)&#125;2019-07-26 11:19:33.867426+0800 HelloOC[16012:1298771] 9 &lt;NSThread: 0x103b19800&gt;&#123;number = 11, name = (null)&#125;2019-07-26 11:19:33.867429+0800 HelloOC[16012:1298765] 3 &lt;NSThread: 0x100504170&gt;&#123;number = 5, name = (null)&#125;2019-07-26 11:19:33.867518+0800 HelloOC[16012:1298770] 8 &lt;NSThread: 0x100503420&gt;&#123;number = 10, name = (null)&#125;2019-07-26 11:19:33.867528+0800 HelloOC[16012:1298766] 4 &lt;NSThread: 0x10393ba60&gt;&#123;number = 6, name = (null)&#125;2019-07-26 11:19:33.867518+0800 HelloOC[16012:1298769] 7 &lt;NSThread: 0x1038017a0&gt;&#123;number = 9, name = (null)&#125; 可以看到这种情况下，执行任务的顺序不固定，并且会开启多条线程同时执行，所以这种时候执行任务的效率最高。 总结 如果队列里的任务必须按照顺序执行，那就选择串行队列。 如果队列里的任务没有执行顺序的需求，那最好选择并发队列，因为并发队列的执行效率更高。 4.系统提供的队列 全局队列：本质上是一个并发队列 12345678//全局队列1.优先级或服务质量，2.保留参数，目前传0/* * DISPATCH_QUEUE_PRIORITY_HIGH * DISPATCH_QUEUE_PRIORITY_DEFAULT * DISPATCH_QUEUE_PRIORITY_LOW * DISPATCH_QUEUE_PRIORITY_BACKGROUND */dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 主队列：不会开启新线程，主队列上的所有任务都只会在主线程上执行 1dispatch_queue_t mainQueue = dispatch_get_main_queue(); 使用方法说明 1234567891011 //全局队列下载资源，主队列更新UIdispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_queue_t mainQueue = dispatch_get_main_queue(); dispatch_async(globalQueue, ^&#123; NSLog(@&quot;在子线程执行耗时操作！&quot;); dispatch_async(mainQueue, ^&#123; NSLog(@&quot;在主线程更新UI&quot;); &#125;); &#125;); 4.GCD Group首先介绍和group相关的一些方法 123456789dispatch_group_t group = dispatch_group_create(); //创建一个任务组dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;task1&quot;); &#125;); //把任务放到队列中，然后将队列放入队列组中dispatch_group_notify(group, queue, ^&#123; NSLog(@&quot;all done&quot;); &#125;); //当所有的任务都执行完成后，追加任务到 group 中，并执行任务。//使用以下两个方法可以实现dispatch_group_async的功能，并且比较灵活dispatch_group_enter(group); //group 中未执行完毕任务数+1dispatch_group_leave(group); //group 中未执行完毕任务数-1dispatch_group_wait(group, DISPATCH_TIME_FOREVER); //（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行 使用示例一： 1234567891011121314151617181920212223242526272829303132dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval: 1.0]; NSLog(@&quot;task-One done&quot;);&#125;);dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval: 0.5]; NSLog(@&quot;task-Two done&quot;);&#125;);dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval: 3.0]; NSLog(@&quot;task-Three done&quot;);&#125;);dispatch_group_notify(group, queue, ^&#123; NSLog(@&quot;all tasks are done&quot;); dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;main thread can go&quot;); &#125;);&#125;);//输出2019-07-26 15:00:34.234033+0800 MyFirstApp[17250:1452448] task-Two done2019-07-26 15:00:34.737764+0800 MyFirstApp[17250:1452450] task-One done2019-07-26 15:00:36.734615+0800 MyFirstApp[17250:1452452] task-Three done2019-07-26 15:00:36.734820+0800 MyFirstApp[17250:1452452] all tasks are done2019-07-26 15:00:36.735016+0800 MyFirstApp[17250:1452412] main thread can go 使用示例二 12345678910111213141516171819202122232425262728293031323334353637383940dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_enter(group);dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval: 1.0]; NSLog(@&quot;task-One done&quot;); dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval: 0.5]; NSLog(@&quot;task-Two done&quot;); dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval: 3.0]; NSLog(@&quot;task-Three done&quot;); dispatch_group_leave(group);&#125;);dispatch_group_wait(group, DISPATCH_TIME_FOREVER);dispatch_async(queue, ^&#123; NSLog(@&quot;all task done&quot;); dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;main thread go&quot;); &#125;);&#125;);//输出2019-07-26 15:04:27.911315+0800 MyFirstApp[17313:1456220] task-Two done2019-07-26 15:04:28.406464+0800 MyFirstApp[17313:1456221] task-One done2019-07-26 15:04:30.407289+0800 MyFirstApp[17313:1456223] task-Three done2019-07-26 15:04:30.407745+0800 MyFirstApp[17313:1456223] all task done2019-07-26 15:04:30.424324+0800 MyFirstApp[17313:1456177] main thread go 相比示例一来说使用dispatch_group_enter和dispatch_group_leave方法来控制更加灵活。 三、NSOperation1.NSOperationNSOperation是对GCD面向对象的封装。它拥有GCD的高效，也拥有面向对象的编程思想。 NSOperation本身是个抽象类，我们要使用它就得使用它的子类。系统给我们提供了两个 NSInvocationOperation：通过selector的形式添加操作 NSBlockOperation：以block的形式添加操作 12345678NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock: ^&#123; NSLog(@&quot;taskOne&quot;); &#125;]; NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil];- (void) task&#123; NSLog(@&quot;taskTwo&quot;);&#125; 2.NSOperationQueue当把操作添加到队列中就会自动异步执行 获取主队列的类方法[NSOperationQueue mainQueue]; 123456NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init]; //创建queue//添加任务[operationQueue addOperation:blockOperation];[operationQueue addOperation:invocationOperation];[operationQueue addOperationWithBlock:^&#123; NSLog(@&quot;1%@&quot;,[NSThread currentThread]); &#125;]; 虽然NSOperationQueue没有并行和串行队列的概念，但是他有一个maxConcurrentOperationCount的属性，表示可以开启的最大线程数目，当其值为1时也就演变成了串行队列。 3.NSOperation的依赖NSOperation的依赖其实就是对当前的任务添加一个前置任务，当前任务必须等待前置任务执行完毕后才能执行。 12345NSBlockOperation *op1, *op2, *op3, *op4; [op4 addDependency:op1];[op4 addDependency:op2];[op4 addDependency:op3]; 上述代码体现的效果为op4必须等待op1, op2, op3都运行完才能执行]]></content>
      <categories>
        <category>Objective-C</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>多线程</tag>
        <tag>NSThread</tag>
        <tag>GCD</tag>
        <tag>NSOperation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C的Runloop]]></title>
    <url>%2F2019%2F09%2F02%2FObjective-C%E7%9A%84Runloop%2F</url>
    <content type="text"><![CDATA[一、Runloop的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。当我们需要让线程能随时处理事件且并不退出，这就称为Event Loop 实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠、在有消息到来时立刻被唤醒。 所以RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。 CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 二、Runloop和线程的关系线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。 12// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic; 线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。 RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。 你只能在一个线程的内部获取其 RunLoop（主线程除外） 12CFRunLoopGetMain();CFRunLoopGetCurrent(); 三、Runloop的使用1.Runloop的Mode NSDefaultRunLoopMode：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到 NSRunLoopCommonModes：占位用的Mode，不是一种真正的Mode，它会同时处理默认模式和UI模式中的事件 需要注意的时在不同的Mode下的事件是独立的，例子：当把timer默认被添加到了RunLoop的defaultMode，而滑动tableView的时候RunLoop切换到了trackingMode，所以timer任务会停止。要解决上述问题只需要把定时器加到UITrackingRunLoopMode中即可 1[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; 2.Runloop处理的事件来源runloop接收输入事件来自两种不同的来源：输入源（input source）和定时源（timer source）。 输入源传递异步事件，通常消息来自于其他线程或程序。定时源则传递同步事件，发生在特定时间或者重复的时间间隔。 a.CFRunLoopSource指用户的操作事件（例如点击屏幕）或者网络端口接收到的信息等，分为如下两种input source。 Source0：被APP所管理，处理内部事件，如UIEvent、CFSocket Source1：被RunLoop和内核所管理，由Mach port驱动，如CFMachPort、CFMessagePort b.CFRunLoopObserver同来用来接收各种回调(callbakcs)。一个Observer一次只能被一个RunLoop注册。当RunLoop的状态切换的时候Observer可以观察到 1234567891011121314151617typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;;//例子CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; NSLog(@&quot;RunLoop状态-%zd&quot;, activity);&#125; );CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);//注意CF对象要释放CFRelease(observer); c.Timer Source12NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * timer)&#123;NSLog(@&quot;Hi Runloop.&quot;);&#125;];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];]]></content>
      <categories>
        <category>Objective-C</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的Runtime]]></title>
    <url>%2F2019%2F08%2F16%2FObjective-C%E4%B8%AD%E7%9A%84Runtime%2F</url>
    <content type="text"><![CDATA[一、什么是动态语言和Runtime静态语言：编译阶段就要决定调用哪个函数，如果函数未实现就会编译报错。 动态语言：编译阶段并不能决定真正调用哪个函数，只要函数声明过即使没有实现也不会报错。 Runtime：一套底层纯C语言API，OC代码最终都会被编译器转化为运行时代码，通过消息机制决定函数调用方式，这也是OC作为动态语言使用的基础。 二、消息机制的基本原理1.编译阶段OC的方法调用都是类似[receiver selector]的形式，在编译阶段[receiver selector]方法被编译器转化 不带参数的方法被编译为：objc_msgSend(receiver，selector) 带参数的方法被编译为：objc_msgSend(recevier，selector，org1，org2，…) 2.运行时阶段消息接收者recever寻找对应的selector，也分为两种情况 接收者能找到对应的selector，直接执行接收receiver对象的selector方法 接收者找不到对应的selector，消息被转发或者临时向接收者添加这个selector对应的实现内容，否则崩溃 三、与Runtime的交互按照与Runtime交互程度从低到高排序分为以下三种方式 1.OC源代码(Objec-C Source Code)OC代码会在编译阶段被编译器转化。OC中的类、方法和协议等在Runtime中都由一些数据结构来定义。所以，我们平时直接使用OC编写代码，其实这已经是在和Runtime进行交互了，只不过这个过程对于我们来说是透明的。 2.NSObject方法(NSObject Methods)123456+ (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;aClass.self&apos; instead&quot;); //返回Class对象- (BOOL)conformsToProtocol:(Protocol *)aProtocol; //判断当前对象是否实现了协议- (BOOL)isKindOfClass:(Class)aClass; //判断是否是自己或者父类- (BOOL)isMemberOfClass:(Class)aClass; //判断是否是自己- (BOOL)respondsToSelector:(SEL)aSelector; //判断是否实现或者继承了某个方法- (IMP)methodForSelector:(SEL)aSelector; //返回该方法的实现的地址 3.使用Runtime函数Runtime系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于/usr/include/objc目录下。在我们工程代码里引用Runtime的头文件，同样能够实现类似OC代码的效果，一些代码示例如下： 12345678#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;Class viewClass = objc_getClass(&quot;UIView&quot;); //相当于 Class viewClass = [UIView class];UIView *view = ((id (*)(id, SEL))objc_msgSend)((id)viewClass,sel_registerName(&quot;alloc&quot;)); //相当于 UIView *view = [UIView alloc]; view = ((id (*)(id, SEL))objc_msgSend)((id)viewClass, sel_registerName(&quot;init&quot;)); //相当于 view = [view init]; 注：要使用objc_msgSend方法需要在项目的Build Settings里的Enable Strict Checking of objc_msgSend Calls改为No。 四、Runtime的数据结构1.id—&gt;objc_object1234567///A pointer to an instance of a class.typedef struct objc_object *id;///Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 2.Class - &gt;objc_classs12345678910111213141516171819typedef struct objc_class *Class; struct objc_class &#123; //Runtime把类对象所属类型就叫做元类，用于描述类对象本身所具有的特征,所以objc_class中的isa指针指向的是元类，每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。 Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; //指向objc_class类所继承的父类，但是如果当前类已经是最顶层的类,则super_class指针为NULL const char * _Nonnull name OBJC2_UNAVAILABLE; //类名 long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; //用于存放所有的成员变量和属性信息 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; //存放对象的所有成员方法 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; //用于记录每次使用类或者实例对象调用的方法。这样每次响应消息的时候，Runtime系统会优先在cache中寻找响应方法 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; //协议链表#endif&#125; OBJC2_UNAVAILABLE; 3.SEL1typedef struct objc_selector *SEL; //SEL在OC中称作方法选择器，用于表示运行时方法的名字 注意：不同类中相同名字的方法对应的方法选择器是相同的。 获得SEL的三种方法 使用@selector(方法名字符串); 使用NSSelectorFromString(@“方法名字符串”); 使用sel_registerName(“方法名字符串”)； 4.Ivar1234567891011/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;struct objc_ivar &#123; char * Nullable ivar_name OBJC2UNAVAILABLE; char * Nullable ivar_type OBJC2UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE;#ifdef LP64 int space OBJC2_UNAVAILABLE;#endif&#125; 5.Method12345678/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;struct objc_method &#123; SEL Nonnull method_name OBJC2UNAVAILABLE; //方法名类型SEL char * Nullable method_types OBJC2UNAVAILABLE; //指向存储方法的参数类型和返回值类型 IMP Nonnull method_imp OBJC2UNAVAILABLE; //指向方法的实现，即方法名和IMP的映射&#125; 6.IMP12/// A pointer to the function of a method implementation.typedef void (IMP)(void / id, SEL, ... */ ); //函数指针的前两个参数必须是id和SEL。 五、深入理解Runtime消息发送1.运行时阶段的消息发送的详细步骤 检测selector 是不是需要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会retain,release 这些函数了。 检测target 是不是nil 对象。ObjC 的特性是允许对一个 nil对象执行任何一个方法不会 Crash，因为会被忽略掉。 如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，若可以找得到就跳到对应的函数去执行。 如果在cache里找不到就找一下方法列表methodLists。 如果methodLists找不到，就到超类的方法列表里寻找，一直找，直到找到NSObject类为止。 如果还找不到，Runtime提供了如下三种方法来处理：动态方法解析、消息接受者重定向、消息重定向 2.动态方法解析(Dynamic Method Resolution)没有找到方法时，Runtime为我们提供一次动态添加方法实现的机会，涉及到的方法有 12345+ (BOOL)resolveClassMethod:(SEL)sel //类方法未找到时调起，可于此添加类方法实现+ (BOOL)resolveInstanceMethod:(SEL)sel //实例方法未找到时调起，可于此添加实例方法实现 BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)/* 参数说明依次为： 被添加方法的类，方法名SEL，方法的IMP，方法的返回值和参数编码*/ 例子如下所示 1234567891011121314151617181920212223242526272829#import &quot;Person.h&quot;#import &lt;objc/runtime.h&gt;@implementation Person//重写父类方法：处理类方法+ (BOOL)resolveClassMethod:(SEL)sel&#123; if(sel == @selector(haveMeal:))&#123; class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(zs_haveMeal:)), &quot;v@&quot;); return YES; //添加函数实现，返回YES &#125; return [class_getSuperclass(self) resolveClassMethod:sel];&#125;//重写父类方法：处理实例方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if(sel == @selector(singSong:))&#123; class_addMethod([self class], sel, class_getMethodImplementation([self class], @selector(zs_singSong:)), &quot;v@&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;+ (void)zs_haveMeal:(NSString *)food&#123; NSLog(@&quot;%s&quot;,__func__);&#125;- (void)zs_singSong:(NSString *)name&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 注意到class_getMethodImplementation的最后一个参数其实是函数的返回值和参数类型编码常用的类型编码有下面这些 类型 说明 类型 说明 c A char Q An unsigned long long i An int f A float s A short d A double l A long B A C++ bool or a C99 _Bool q A long long v A void C An unsigned char * A character string (char *) I An unsigned int @ An object (whether statically typed or typed id) S An unsigned short # A class object (Class) L An unsigned long : A method selector (SEL) 3.消息接收者重定向使用Runtime替换消息接收者的为其他对象，从而保证程序的继续执行。 12345678910111213141516171819202122//重定向类方法的消息接收者，返回一个类+ (id)forwardingTargetForSelector:(SEL)aSelector//重定向实例方法的消息接受者，返回一个实例对象- (id)forwardingTargetForSelector:(SEL)aSelector //以下是使用示例//重定向类方法：返回一个类对象+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == @selector(takeExam:)) &#123; return [Student class]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;//重定向实例方法：返回类的实例- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == @selector(learnKnowledge:)) &#123; return self.student; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 动态方法解析阶段返回NO时，我们可以通过forwardingTargetForSelector可以修改消息的接收者，该方法返回参数是一个对象，如果这个对象是非nil，非self，系统会将运行的消息转发给这个对象执行。否则，继续查找其他流程。 4.消息重定向当以上两种方法无法生效，那么这个对象会因为找不到相应的方法实现而无法响应消息，此时Runtime系统会通过forwardInvocation：消息通知该对象，给予此次消息发送最后一次寻找IMP的机会 1234567891011121314151617181920212223242526272829- (void)forwardInvocation:(NSInvocation *)anInvocation；/*anInvocation是forwardInvocation唯一参数，它封装了原始的消息和消息参数所以我们得重写另一个函数：methodSignatureForSelector这是因为在forwardInvocation: 消息发送前，Runtime系统会向对象发送methodSignatureForSelector消息，并取到返回的方法签名用于生成NSInvocation对象*/ //以下是示例-(void)forwardInvocation:(NSInvocation *)anInvocation&#123; //1.从anInvocation中获取消息 SEL sel = anInvocation.selector; //2.判断Student方法是否可以响应应sel if ([self.student respondsToSelector:sel]) &#123; //2.1若可以响应，则将消息转发给其他对象处理 [anInvocation invokeWithTarget:self.student]; &#125;else&#123; //2.2若仍然无法响应，则报错：找不到响应方法 [self doesNotRecognizeSelector:sel]; &#125;&#125;//需要从这个方法中获取的信息来创建NSInvocation对象，因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。- (NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector&#123; NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector]; if (!methodSignature) &#123; methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;]; &#125; return methodSignature;&#125; 总结 forwardingTargetForSelector仅支持一个对象的返回，也就是说消息只能被转发给一个对象，而forwardInvocation可以将消息同时转发给任意多个对象，这就是两者的最大区别。 forwardInvocation能够修改消息的内容，从而实现更强大的功能]]></content>
      <categories>
        <category>Objective-C</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Runtime</tag>
        <tag>消息机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的内存管理]]></title>
    <url>%2F2019%2F08%2F16%2FObjective-C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、内存管理简介内存管理顾名思义就是对程序使用的内存进行管理，以下是OC进行内存管理的对象 相比Java中的垃圾回收器，OC中也存在着垃圾回收器但是在IOS不支持使用垃圾回收而是使用ARC来进行内存管理 这里补充一下自己的看法，个人认为在IOS上不使用垃圾回收的可能是垃圾回收需要像Java中一样需要一个stop the world的点来进行垃圾回收，这样容易造成卡顿的现象带来不好的用户体验。 1.什么是引用计数法程序中的每一个对象都有一个与之相关联的整数，被称作它的引用计数器或保留计数器。 当使用alloc、new或copy创建一个对象是，保留计数器置为一 当某段代码需要访问一个对象是，将对象的保留计数器加一 当某段代码结束对象访问时，将对象的保留计数器减一 当保留计数器的值为0时，对象将被销毁 2.什么是MRC在MRC下，OC的内存管理需要程序员自己编写release、retain等代码来维护对象的保留计数器。 当使用alloc/new/copy/mutableCopy等方法生成并持有一个对象之后引用计数器值默认为1； 给对象发送一条retain消息也可以持有对象，引用计数值+1，并返回当前对象； 当给对象发送一条release消息之后它的引用计数器值减1； 给对象发送retainCount消息（不准确，就算一个对象已经释放，retainCount的值也可能是1），可以获得当前的引用计数值。 需要注意的是对象之间可能交叉引用，此时需要遵循一个法则：谁创建，谁释放 3.什么是ARC(Automatic reference counting)ARC是LLVM编译器和Runtime系统相互协作的一个结果,ARC利用LLVM编译器在编译阶段自动帮我们生成release、retain、autorelease代码，而弱引用这样则是利用Runtime在程序运行过程中监控到对象销毁的时候将指向对象的弱引用清空。 ARC下的所有权修饰符 __strong：是id类型和对象类型默认的所有权修饰符，表示强引用，会改变保留计数器 __weak：弱引用不增加对象的引用计数，不能持有对象实例。一般用于处理循环引用问题，如在delegate关系中防止循环引用或者用来修饰指向由Interface Builder编辑生成的UI控件 __unsafe_unretained：不属于编译器的内存管理对象，可理解为MRC时代的assign，不增加所引用对象的引用计数值，但是不保证指针指向的可访问性（对象在被dealloc时，指向它的弱引用不会自动被置nil，存在野指针情况） 4.ARC和垃圾回收的对比ARC 相对于 GC 的优点： ARC 工作在编译期，在运行时没有额外开销。 ARC 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 GC 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。 ARC 相对于 GC 的缺点： GC基本上完全不用处理内存管理问题，而 ARC 还是需要处理类似循环引用这种内存管理问题。 二、自动释放池OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机，即当我们创建了一个对象，并把他加入到了自动释放池中时，他不会立即被释放，会等到一次runloop结束或者作用域超出{}或者超出[pool release]之后再被释放。 1.在MRC下的自动释放池1234NSAutoreleasePool *releasePool = [[NSAutoreleasePool alloc] init];Person *person = [[Person alloc] init];[person autorelease]; //将person对象加入自动释放池中[releasePool release]; //在自动释放池release时，会自动的向池中所有的对象发送release消息来释放对象。 2.在ARC下的自动释放池123@autoreleasepool&#123; Person *person = [[Person alloc] init]; //在该代码块中的对象自动被加入自动释放池中，在代码块结束后统一release &#125; 3.自动释放池的源码分析@autoreleasepool用C++编译器编译后其实是下面的内容 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 所以在创建自动释放池的代码等同于如下代码 12345void main(int argc, const char * argv[]) &#123; void * autoreleasepoolobj = objc_autoreleasePoolPush(); objc_autoreleasePoolPop(autoreleasepoolobj);&#125; 而创建和析构方法的内容其实是对AutoreleasePoolPage的封装 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 而AutoreleasePoolPage是C++中的一个类 123456789class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;&#125;; 其中 magic：对当前 AutoreleasePoolPage 完整性的校验 next：指针作为游标，指向栈顶最新add进来的autorelease对象的下一个位置，即每个AutoreleasePoolPage都是一个存放对象指针的栈，当空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入 thread：指向向当前线程 parent、child：AutoreleasePoolPage是一个双链表结构的节点，parent指向上一个节点，child指向下一个节点 所以综上自动释放池其实是对存储在AutoreleasePoolPage的对象进行释放 还需要补充的一点是AutoreleasePool的嵌套使用，通过将POOL_SENTINEL加入到AutoReasePoolPage来间隔每个嵌套。 1#define POOL_SENTINEL nil 三、内存管理规则 当使用new、alloc或copy创建一个对象时，该对象的保留计数器的值为1。当不再使用该对象时，你应该向该对象发送一条release或autorelease消息 当你通过其他的方法获得一个对象时，假设该对象的保留计数器的值为1，而且已经被设置为自动释放，则不需要执行任何操作。如果你打算在一段时间内拥有该对象，则需要保留它并且在操作完成时释放它 如果你保留了某个对象，就需要释放或自动释放对象。必须保持retain和release方法使用次数相同]]></content>
      <categories>
        <category>Objective-C</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的property]]></title>
    <url>%2F2019%2F08%2F16%2FObjective-C%E4%B8%AD%E7%9A%84property%2F</url>
    <content type="text"><![CDATA[原子性特性 nonatomic非原子访问 大多数情况下都适用该特性 atomic （默认）原子访问 存取特性 readonly表示只读属性，只会生成getter方法 readwrite （默认）同时生成getter和setter方法 内存管理特性 strong（用于对象的默认值）表示持有这个对象的强引用 weak（用于对象）表示持有这个对象的弱应用，不会增加retainCount的值 assign主要用于简单数据类型）简单的赋值，主要用于基本数据类型，如果用于对象则效果和weak差不多，但是不会自动赋值为nil copy创建一个新的对象，新的对象和旧的对象是独立的两个对象，常用于可变属性，例：NSMutableArray retain （非ARC下使用）给retainCount的值加一 存取方法重命名 getter=对get方法重命名，在等号后面写上getter的名字 setter=对set方法重命名，在等号后面写上setter的名字 Nullability nullable对象可为空 nonnull对象不可为空 由于在大多数情况下属性都是nonnull的，所以苹果公司定义了两个宏，NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END，将所有属性包在这两个宏中，就无需写nonnull修饰语了，只需要在「可为空」的属性里，写上nullable即可 null_unspecified未指定 null_resettable调用setter去reset属性时，可以传入nil，但是getter返回值，不为空。这样即使赋值为nil，也会返回一个非空的值 注意：如果设置为null_resettable，则要重写setter或getter其中之一，自己做判断，确保真正返回的值不是nil。否则报警告：Synthesized setter ‘setName:’ for null_resettable property ‘name’ does not handle nil 对上述特性的使用总结 几乎所有的情况，都写上nonatomic 对外只读的，写上readonly 一般的对象属性，写上strong(默认) 需要解决循环引用的问题使用weak 有mutable的对象属性，strong改为copy 基本数据类型(int, float ,BOOL)，使用assign 一些补充 在.m文件中写上 @dynamic 表示不自动生成getter和setter方法 在一般情况下尽量使用accessor方法(即点表达式)来访问一个property，而不是直接访问它对应的实例变量。但是在一个对象的init方法、deallocate方法和自定义的accessor方法中不建议调用accessor方法。]]></content>
      <categories>
        <category>Objective-C</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的使用]]></title>
    <url>%2F2019%2F08%2F15%2Fmarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MarkDown的使用标题使用#来标记标题，可以使用1-6个#来标记不同级别的标题(一级到六级) text123#一级标题###三级标题######六级标题 字体使用成对的和_来标识字体(和_的作用相同) 斜体粗体粗斜体 text123456*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___ 分隔线可以在一行中使用&gt;=3个数量的*或-来标识分隔线 text12---****** 删除线如果想在文字上添加删除线，在文字的左右分别添加两个波浪线~即可 删除的文字 text1~~删除的文字~~ 下划线如果想为一行文字添加下划线，在文字的两端使用HTML的来标识 下划线文本 text1&lt;u&gt;下划线文本&lt;/u&gt; 脚注如果想在文字的右上角添加说明 text1[^要变成脚注的文字]:脚注的说明 列表markdown支持无序列表或者有序列表 无序列表使用单个*或者-或者+来标识一行，注意标记后面要添加一个空格 第一项 第二项 第三项 text123* 第一项+ 第二项- 第三项 有序列表使用数字加.即可 1.第一项2.第二项3.第三项 text1231.第一项2.第二项3.第三项 列表嵌套只需要在上一个列表的基础上添加四个空格即可 text1231.第一项 * 嵌套的第二项 + 嵌套的第三项 区块引用使用&gt;来标识区块引用 最外层 第二层 第三层 text123&gt;最外层&gt;&gt;第二层&gt;&gt;&gt;第三层 如果要在列表中使用区块引用，需要在&gt;前加四个空格的缩进 第一项 第一层区块 text12* 第一项 &gt;第一层区块 代码可以使用成对反引号`来标识一个函数或者片段 System.out text1`System.out` 可以使用三个成对的反引号`来标识一个代码块，并且可以附加使用的语言 1NSLog(@&quot;Hello world!&quot;); text123```Objective-CNSLog(@&quot;Hello world!&quot;);``` 链接例：链接说明 text1[百度链接](www.baidu.com) 或者直接使用&lt;链接&gt; text1&lt;www.baidu.com&gt; 图片添加图片可以使用以下方式注意，图片地址可以是本地路径也可以是网络路径 text1![alt 我的图片](/Users/mtdp/Desktop/test.png) 表格制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 表头 表头二 表头三 内容 内容二 内容三 text123| 表头 | 表头二 | 表头三 || ---: | :--- | :--: || 内容 | 内容二 | 内容三 |]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C的基本使用]]></title>
    <url>%2F2019%2F08%2F14%2FObjective-C%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、OC的基础语法Objective-C是在C语言的基础上，增加了一些自己独有的特性，将面向过程的C语言添加了面向对象编程的功能，由于之前已经有C的经验，下面只介绍Objective-C的特性 关键字OC中独有的大部分关键字是以@开头的，常用的关键字有：@interface、@implementation、@end @public、@protected、@private、@selector @try、@catch、@throw、@finally @protocol、@optional、@required、@class @property、@synthesize、@dynamic等。以及一些不以@开头的但是是对C的扩展的关键字：self、super、id、instancetype等。 #import和C中的#include不同的是import不会重复包含相同的头文件。 NSLogNSLog输出完毕信息之后会默认加一个\n，如果我们手动加了一个\n，NSLog的自动换行就会失效。 在输出信息的同时还会输出一些与程序有关的其他信息(系统时间、程序名、进程ID、线程ID)。 NSLog函数支持printf函数的全部格式控制符，其用法也相同。 NSLog函数的字符串参数前面必须要加一个@符号，这是OC里的字符串格式。 NSLog可以使用%@格式控制符输出对象，而printf不能输出对象。 NSLog函数的第一个参数是NSString类型的指针，所以必须给一个OC字符串。 二、OC的基本数据类型总览 自动数据类型转换顺序short –&gt; int –&gt; long –&gt; long long –&gt; float –&gt; double –&gt; long double（注意：整型往浮点型自动转换） 强制类型转换：整型转化为浮点型时基本不会有太大的变化，而当浮点转化为整型时，数值的小数部分会直接舍去 OC中NSLog输出函数的格式 格式字符 说明 格式字符 说明 x 无符号十六进制 g 自动选用%f或%e输出，保证以最简形式输出，并不会输出无意义的0 u 无符号十进制 p 以十六尽职形式输出指针变量所代表的地址值 s 输出C风格字符串 l 用在d、o、x、u之前用于输出长整型；在f、e、g之前用于输出长浮点型 o 无符号八进制 e 指数形式输出，数值不分默认输出6位小数 m 用于制定输出数据所占的最小宽度为m位 .n 对于浮点数，表示输出n位小数，对于字符串，表示截取的字符个数 d 带符号十进制 f 小数形式输出，默认输出6位小数 c 字符形式，只输出一个字符 @ 输出OC对象 - 表述输出的数值向左边对齐 枚举（enum）枚举的本质是无符号整数，可以通过直接用数值的方式给枚举变量进行赋值。 12345678910111213typedef NS_OPTIONS(NSUInteger, Event)&#123; EventTouchDown = 1 &lt;&lt; 0, EventTouchDownRepeat = 1 &lt;&lt; 1, EventTouchDragInside = 1 &lt;&lt; 2&#125;;typedef NS_ENUM(NSInteger, Alignment)&#123; AlignmentCenter = 1, AlignmentLeft = 2, AlignmentRight = 3&#125;; 在使用或运算操作两个枚举值时，C++默认为运算结果的数据类型是枚举的底层数据类型即NSUInteger,且C++不允许它隐式转换为枚举类型本身，所以C++模式下定义了NS_OPTIONS宏以保证不出现类型转换。 所以在我们需要同时存在多个枚举同时使用时要使用NS_OPTIONS，普通情况下使用NS_ENUM即可。 布尔（BOOL）OC的底层实际上是使用signed char来代表BOOL，所以如果一个非0整数的低八位表示的数为0，则其转化位BOOL类型值为NO。即只会取最后8位数据来进行判断。 NSInterger大致相当于long型整数 NSUInterger 大致相当于unsigned long型整数 CGFLoat在64位平台大致相当于double，在32位系统大致相当于float]]></content>
      <categories>
        <category>Objective-C</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>基本类型</tag>
      </tags>
  </entry>
</search>
