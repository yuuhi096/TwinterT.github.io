<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Objective-C中的内存管理]]></title>
    <url>%2F2019%2F08%2F16%2FObjective-C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、内存管理简介内存管理顾名思义就是对程序使用的内存进行管理，以下是OC进行内存管理的对象 相比Java中的垃圾回收器，OC中也存在着垃圾回收器但是在IOS不支持使用垃圾回收而是使用ARC来进行内存管理 这里补充一下自己的看法，个人认为在IOS上不使用垃圾回收的可能是垃圾回收需要像Java中一样需要一个stop the world的点来进行垃圾回收，这样容易造成卡顿的现象带来不好的用户体验。 1.什么是引用计数法程序中的每一个对象都有一个与之相关联的整数，被称作它的引用计数器或保留计数器。 当使用alloc、new或copy创建一个对象是，保留计数器置为一 当某段代码需要访问一个对象是，将对象的保留计数器加一 当某段代码结束对象访问时，将对象的保留计数器减一 当保留计数器的值为0时，对象将被销毁 2.什么是MRC在MRC下，OC的内存管理需要程序员自己编写release、retain等代码来维护对象的保留计数器。 当使用alloc/new/copy/mutableCopy等方法生成并持有一个对象之后引用计数器值默认为1； 给对象发送一条retain消息也可以持有对象，引用计数值+1，并返回当前对象； 当给对象发送一条release消息之后它的引用计数器值减1； 给对象发送retainCount消息（不准确，就算一个对象已经释放，retainCount的值也可能是1），可以获得当前的引用计数值。 需要注意的是对象之间可能交叉引用，此时需要遵循一个法则：谁创建，谁释放 3.什么是ARC(Automatic reference counting)ARC是LLVM编译器和Runtime系统相互协作的一个结果,ARC利用LLVM编译器在编译阶段自动帮我们生成release、retain、autorelease代码，而弱引用这样则是利用Runtime在程序运行过程中监控到对象销毁的时候将指向对象的弱引用清空。 ARC下的所有权修饰符 __strong：是id类型和对象类型默认的所有权修饰符，表示强引用，会改变保留计数器 __weak：弱引用不增加对象的引用计数，不能持有对象实例。一般用于处理循环引用问题，如在delegate关系中防止循环引用或者用来修饰指向由Interface Builder编辑生成的UI控件 __unsafe_unretained：不属于编译器的内存管理对象，可理解为MRC时代的assign，不增加所引用对象的引用计数值，但是不保证指针指向的可访问性（对象在被dealloc时，指向它的弱引用不会自动被置nil，存在野指针情况） 4.ARC和垃圾回收的对比ARC 相对于 GC 的优点： ARC 工作在编译期，在运行时没有额外开销。 ARC 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 GC 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。 ARC 相对于 GC 的缺点： GC基本上完全不用处理内存管理问题，而 ARC 还是需要处理类似循环引用这种内存管理问题。 二、自动释放池OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机，即当我们创建了一个对象，并把他加入到了自动释放池中时，他不会立即被释放，会等到一次runloop结束或者作用域超出{}或者超出[pool release]之后再被释放。 1.在MRC下的自动释放池1234NSAutoreleasePool *releasePool = [[NSAutoreleasePool alloc] init];Person *person = [[Person alloc] init];[person autorelease]; //将person对象加入自动释放池中[releasePool release]; //在自动释放池release时，会自动的向池中所有的对象发送release消息来释放对象。 2.在ARC下的自动释放池123@autoreleasepool&#123; Person *person = [[Person alloc] init]; //在该代码块中的对象自动被加入自动释放池中，在代码块结束后统一release &#125; 3.自动释放池的源码分析@autoreleasepool用C++编译器编译后其实是下面的内容 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 所以在创建自动释放池的代码等同于如下代码 12345void main(int argc, const char * argv[]) &#123; void * autoreleasepoolobj = objc_autoreleasePoolPush(); objc_autoreleasePoolPop(autoreleasepoolobj);&#125; 而创建和析构方法的内容其实是对AutoreleasePoolPage的封装 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 而AutoreleasePoolPage是C++中的一个类 123456789class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;&#125;; 其中 magic：对当前 AutoreleasePoolPage 完整性的校验 next：指针作为游标，指向栈顶最新add进来的autorelease对象的下一个位置，即每个AutoreleasePoolPage都是一个存放对象指针的栈，当空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入 thread：指向向当前线程 parent、child：AutoreleasePoolPage是一个双链表结构的节点，parent指向上一个节点，child指向下一个节点 所以综上自动释放池其实是对存储在AutoreleasePoolPage的对象进行释放 还需要补充的一点是AutoreleasePool的嵌套使用，通过将POOL_SENTINEL加入到AutoReasePoolPage来间隔每个嵌套。 1#define POOL_SENTINEL nil 三、内存管理规则 当使用new、alloc或copy创建一个对象时，该对象的保留计数器的值为1。当不再使用该对象时，你应该向该对象发送一条release或autorelease消息 当你通过其他的方法获得一个对象时，假设该对象的保留计数器的值为1，而且已经被设置为自动释放，则不需要执行任何操作。如果你打算在一段时间内拥有该对象，则需要保留它并且在操作完成时释放它 如果你保留了某个对象，就需要释放或自动释放对象。必须保持retain和release方法使用次数相同]]></content>
      <categories>
        <category>Objective-C</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的property]]></title>
    <url>%2F2019%2F08%2F16%2FObjective-C%E4%B8%AD%E7%9A%84property%2F</url>
    <content type="text"><![CDATA[原子性特性 nonatomic非原子访问 大多数情况下都适用该特性 atomic （默认）原子访问 存取特性 readonly表示只读属性，只会生成getter方法 readwrite （默认）同时生成getter和setter方法 内存管理特性 strong（用于对象的默认值）表示持有这个对象的强引用 weak（用于对象）表示持有这个对象的弱应用，不会增加retainCount的值 assign主要用于简单数据类型）简单的赋值，主要用于基本数据类型，如果用于对象则效果和weak差不多，但是不会自动赋值为nil copy创建一个新的对象，新的对象和旧的对象是独立的两个对象，常用于可变属性，例：NSMutableArray retain （非ARC下使用）给retainCount的值加一 存取方法重命名 getter=对get方法重命名，在等号后面写上getter的名字 setter=对set方法重命名，在等号后面写上setter的名字 Nullability nullable对象可为空 nonnull对象不可为空 由于在大多数情况下属性都是nonnull的，所以苹果公司定义了两个宏，NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END，将所有属性包在这两个宏中，就无需写nonnull修饰语了，只需要在「可为空」的属性里，写上nullable即可 null_unspecified未指定 null_resettable调用setter去reset属性时，可以传入nil，但是getter返回值，不为空。这样即使赋值为nil，也会返回一个非空的值 注意：如果设置为null_resettable，则要重写setter或getter其中之一，自己做判断，确保真正返回的值不是nil。否则报警告：Synthesized setter ‘setName:’ for null_resettable property ‘name’ does not handle nil 对上述特性的使用总结 几乎所有的情况，都写上nonatomic 对外只读的，写上readonly 一般的对象属性，写上strong(默认) 需要解决循环引用的问题使用weak 有mutable的对象属性，strong改为copy 基本数据类型(int, float ,BOOL)，使用assign 一些补充 在.m文件中写上 @dynamic 表示不自动生成getter和setter方法 在一般情况下尽量使用accessor方法(即点表达式)来访问一个property，而不是直接访问它对应的实例变量。但是在一个对象的init方法、deallocate方法和自定义的accessor方法中不建议调用accessor方法。]]></content>
      <categories>
        <category>Objective-C</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的使用]]></title>
    <url>%2F2019%2F08%2F15%2Fmarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MarkDown的使用标题使用#来标记标题，可以使用1-6个#来标记不同级别的标题(一级到六级) text123#一级标题###三级标题######六级标题 字体使用成对的和_来标识字体(和_的作用相同) 斜体粗体粗斜体 text123456*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___ 分隔线可以在一行中使用&gt;=3个数量的*或-来标识分隔线 text12---****** 删除线如果想在文字上添加删除线，在文字的左右分别添加两个波浪线~即可 删除的文字 text1~~删除的文字~~ 下划线如果想为一行文字添加下划线，在文字的两端使用HTML的来标识 下划线文本 text1&lt;u&gt;下划线文本&lt;/u&gt; 脚注如果想在文字的右上角添加说明 text1[^要变成脚注的文字]:脚注的说明 列表markdown支持无序列表或者有序列表 无序列表使用单个*或者-或者+来标识一行，注意标记后面要添加一个空格 第一项 第二项 第三项 text123* 第一项+ 第二项- 第三项 有序列表使用数字加.即可 1.第一项2.第二项3.第三项 text1231.第一项2.第二项3.第三项 列表嵌套只需要在上一个列表的基础上添加四个空格即可 text1231.第一项 * 嵌套的第二项 + 嵌套的第三项 区块引用使用&gt;来标识区块引用 最外层 第二层 第三层 text123&gt;最外层&gt;&gt;第二层&gt;&gt;&gt;第三层 如果要在列表中使用区块引用，需要在&gt;前加四个空格的缩进 第一项 第一层区块 text12* 第一项 &gt;第一层区块 代码可以使用成对反引号`来标识一个函数或者片段 System.out text1`System.out` 可以使用三个成对的反引号`来标识一个代码块，并且可以附加使用的语言 1NSLog(@&quot;Hello world!&quot;); text123```Objective-CNSLog(@&quot;Hello world!&quot;);``` 链接例：链接说明 text1[百度链接](www.baidu.com) 或者直接使用&lt;链接&gt; text1&lt;www.baidu.com&gt; 图片添加图片可以使用以下方式注意，图片地址可以是本地路径也可以是网络路径 text1![alt 我的图片](/Users/mtdp/Desktop/test.png) 表格制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 表头 表头二 表头三 内容 内容二 内容三 text123| 表头 | 表头二 | 表头三 || ---: | :--- | :--: || 内容 | 内容二 | 内容三 |]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C的基本使用]]></title>
    <url>%2F2019%2F08%2F14%2FObjective-C%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、OC的基础语法Objective-C是在C语言的基础上，增加了一些自己独有的特性，将面向过程的C语言添加了面向对象编程的功能，由于之前已经有C的经验，下面只介绍Objective-C的特性 关键字OC中独有的大部分关键字是以@开头的，常用的关键字有：@interface、@implementation、@end @public、@protected、@private、@selector @try、@catch、@throw、@finally @protocol、@optional、@required、@class @property、@synthesize、@dynamic等。以及一些不以@开头的但是是对C的扩展的关键字：self、super、id、instancetype等。 #import和C中的#include不同的是import不会重复包含相同的头文件。 NSLogNSLog输出完毕信息之后会默认加一个\n，如果我们手动加了一个\n，NSLog的自动换行就会失效。 在输出信息的同时还会输出一些与程序有关的其他信息(系统时间、程序名、进程ID、线程ID)。 NSLog函数支持printf函数的全部格式控制符，其用法也相同。 NSLog函数的字符串参数前面必须要加一个@符号，这是OC里的字符串格式。 NSLog可以使用%@格式控制符输出对象，而printf不能输出对象。 NSLog函数的第一个参数是NSString类型的指针，所以必须给一个OC字符串。 二、OC的基本数据类型总览 自动数据类型转换顺序short –&gt; int –&gt; long –&gt; long long –&gt; float –&gt; double –&gt; long double（注意：整型往浮点型自动转换） 强制类型转换：整型转化为浮点型时基本不会有太大的变化，而当浮点转化为整型时，数值的小数部分会直接舍去 OC中NSLog输出函数的格式 格式字符 说明 格式字符 说明 x 无符号十六进制 g 自动选用%f或%e输出，保证以最简形式输出，并不会输出无意义的0 u 无符号十进制 p 以十六尽职形式输出指针变量所代表的地址值 s 输出C风格字符串 l 用在d、o、x、u之前用于输出长整型；在f、e、g之前用于输出长浮点型 o 无符号八进制 e 指数形式输出，数值不分默认输出6位小数 m 用于制定输出数据所占的最小宽度为m位 .n 对于浮点数，表示输出n位小数，对于字符串，表示截取的字符个数 d 带符号十进制 f 小数形式输出，默认输出6位小数 c 字符形式，只输出一个字符 @ 输出OC对象 - 表述输出的数值向左边对齐 枚举（enum）枚举的本质是无符号整数，可以通过直接用数值的方式给枚举变量进行赋值。 12345678910111213typedef NS_OPTIONS(NSUInteger, Event)&#123; EventTouchDown = 1 &lt;&lt; 0, EventTouchDownRepeat = 1 &lt;&lt; 1, EventTouchDragInside = 1 &lt;&lt; 2&#125;;typedef NS_ENUM(NSInteger, Alignment)&#123; AlignmentCenter = 1, AlignmentLeft = 2, AlignmentRight = 3&#125;; 在使用或运算操作两个枚举值时，C++默认为运算结果的数据类型是枚举的底层数据类型即NSUInteger,且C++不允许它隐式转换为枚举类型本身，所以C++模式下定义了NS_OPTIONS宏以保证不出现类型转换。 所以在我们需要同时存在多个枚举同时使用时要使用NS_OPTIONS，普通情况下使用NS_ENUM即可。 布尔（BOOL）OC的底层实际上是使用signed char来代表BOOL，所以如果一个非0整数的低八位表示的数为0，则其转化位BOOL类型值为NO。即只会取最后8位数据来进行判断。 NSInterger大致相当于long型整数 NSUInterger 大致相当于unsigned long型整数 CGFLoat在64位平台大致相当于double，在32位系统大致相当于float]]></content>
      <categories>
        <category>Objective-C</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>基本类型</tag>
      </tags>
  </entry>
</search>
